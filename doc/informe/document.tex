\documentclass[12pt]{article}

%Packages
\usepackage[latin1]{inputenc}
% Esto es para que el LaTeX sepa que el texto estÃ¡ en espaÃ±ol:
\usepackage[spanish]{babel}
\usepackage[x11names,table]{xcolor}

% Paquetes de la AMS:
%\usepackage[total={6in,11in},top=0.50in, left=1in]{geometry}
\usepackage[top=1in, left=1in, right=1in, bottom=1in]{geometry}
\usepackage{amsmath, amsthm, amsfonts}
\usepackage{graphics}
\usepackage{listings}
\usepackage{float}
\usepackage{epsfig}
\usepackage{amssymb}


\lstset{ %
	language=Prolog, % lenguaje
	basicstyle=\normalsize\ttfamily,
	keywordstyle=\color{blue},
	commentstyle=\color{blue!50},
	backgroundcolor=\color{gray!9},
	identifierstyle = \color{gray!161},
	stringstyle = \color{yellow},
	numberstyle = \color{green},
	columns=fullflexible,
	showspaces=false
}



\newtheorem{thm}{Teorema}[section]
\newtheorem{cor}[thm]{Corolario}
\newtheorem{lem}[thm]{Lema}
\newtheorem{prop}[thm]{ProposiciÃ³n}
\theoremstyle{definition}
\newtheorem{defn}[thm]{Definicion}
\theoremstyle{remark}
\newtheorem{rem}[thm]{ObservaciÃ³n}

\def\RR{\mathbb{R}}

\renewcommand{\labelenumi}{$\bullet$}
\newtheorem{definition}{Definición}[section]
\newtheorem{theorem}{Teorema}[section]
\newtheorem{corollary}{Corolario}[section]
\newtheorem{lemma}{Lema}[section]
\newtheorem{proposition}{Proposición}[section]
\newcommand{\statement}[3]{
	\begin{center}
		{ \fcolorbox {gray!11}{gray!11}{
				\begin{minipage}[h!]{\textwidth}
					\begin{#1}\label{#3}
						#2
					\end{#1}
				\end{minipage} } }
			\end{center}}
			\renewcommand{\proof}[1]{{\it Demostración}\\ #1 \hfill\blacksquare}
\newcommand{\pagediv}[4]
{
	\begin{figure}[!h]
		\begin{minipage}[b]{#1\textwidth}
			#3			
		\end{minipage} \hfill 
		\begin{minipage}[b]{#2\textwidth}
			#4
		\end{minipage}
	\end{figure}
	
}



%define title
\author{
	Dalianys P\'erez Perera\\
	Dayany Alfaro González\\
	C-411 \\
}
\title{Azul   \\
	Programación Declarativa
	}

\date{}
\begin{document}
%generates the title
\maketitle

\selectlanguage{spanish}

\newpage
%insert table contents
\tableofcontents
\newpage

\section {Ideas generales de la solución}
$Azul$ como la mayoría de los juegos de mesa requieren de una mesa, o soporte físico para poder jugarse, en estos el azar es una característica muy importante además del uso de estrategias por cada uno de los jugadores . Para la reproducción del juego es fundamental una primera etapa de análisis y diseño orientado a objetos con el objetivo de representar cada una de sus partes, siendo esto posible mediante la creación de objetos dinámicos.

Al analizar las especificaciones y reglas del juego se tuvo en cuenta que los jugadores actuarían como agentes sin la intervención de un usuario y tienen conocimiento del estado del juego(ambiente) en todo momento, además de poder modificar su propio estado y el de su ambiente. A cada jugador se le asigna un $Id$ y está constituido por un tablero personal conformado por la zona de preparación(\lstinline|Stair|) , el muro(\lstinline|Wall|), la fila de penalización(\lstinline|Floor|) y una puntuación parcial(\lstinline|Score|). Mientras que el estado del ambiente está dado por los respectivos estados de las factorías, el centro de la mesa, la tapa de la caja y el turno del siguiente jugador.

\subsection{Diseño y modelación}
Sobre la base de los conceptos encontrados durante el análisis del problema, nuestra propuesta de solución agrupa los predicados implementados en los siguientes módulos:

\begin{itemize}
	\item {\bf environment.pl} : Contiene los predicados que modelan el transcurso de la partida a través de la definición de los conceptos del ambiente del juego vistos anteriormente. Aquí se definen los predicados dinámicos: 
		\begin{itemize}
			\item \lstinline| first_player(P).| triunfa si P es el $Id$ del primer jugador de la siguiente ronda. En la primera ronda se comienza por el jugador con $Id = 1$ y en lo adelante será el primero en seleccionar azulejos del centro  
			
			\item \lstinline| next_turn(P).| triunfa si P es el $Id$ del jugador que le corresponde la siguiente jugada.
			
			\item \lstinline| cant_factory(F).| triunfa si F es la cantidad de factorías existentes en la partida actual.
			
			\item \lstinline| factory(F, B, Y, R, G, W).| triunfa si la factoría con $Id$ = F tiene cantidades de azulejos iguales a B azules, Y amarillos, R rojos, G verdes y W blancos.
			
			\item  \lstinline| center(Chip, B, Y, R, G, W).| triunfa si el centro de la mesa tiene cantidades de azulejos iguales a B azules, Y amarillos, R rojos, G verdes y W blancos y además si la ficha de jugador inicial aún está en el centro entonces Chip = 1, si no Chip = 0.
			\item \lstinline| bag(N, L).| triunfa si la bolsa tiene N azulejos y L es la lista que los contiene. Por ejemplo si la bolsa tuviera un azulejo de cada color entonces N sería igua a 5 y L = $[1, 2, 3, 4, 5]$.
			
			\item \lstinline| lid(N, L).| triunfa si la tapa tiene N azulejos y L es la lista que los contiene.
			
			\item \lstinline| stop_play(S).| trinfa si se cumple condición de parada del juego y S = 1, si el juego no ha terminado S = 0.
			
		\end{itemize}
		
		La facilidad de unificación brindada por el lenguaje nos permite consultar cada uno de los atributos anteriores en cualquier momento deseado, siempre y cuando estos estén debidamente inicializados en la base de conocimiento de Prolog. Por ejemplo si queremos saber el estado de la factoría número 2 ejecutamos \lstinline| factory(2, B, Y, R, G, W).|  y las variables libres unificarán de la siguiente forma \space \lstinline| B = 1 , Y = 2, R = 1, G = W, W = 0.| indicando que tiene 1 azulejo azul, 2 amarillos y 1 rojo.\\
		
		Cada uno de los atributos anteriores tiene su correspondiente predicado que modifica sus valores en la base de conocimiento, por ejemplo:
	\begin{lstlisting}
set_first_player(ID) :- (retract(first_player(_)), !;  true),
                             assert(first_player(ID)).

set_factory(ID,B,Y,R,G,W) :- (retract(factory(ID,_,_,_,_,_)), !; true),
                                assert(factory(ID,B,Y,R,G,W)).
	\end{lstlisting}
	
	Para el caso de la bolsa(\lstinline|bag|), el centro(\lstinline|center|) y la tapa(\lstinline|lid|) , las modificaciones que se les pueden realizar son la adición o eliminación de un azulejo y el rellenado de la bolsa con todos los azulejos de la tapa una vez se quede vacía.
	
	A continuación se observan los predicados que encapsulan el concepto de bolsa, que como ya se ha dicho, está representada por una lista con los colores de sus azulejos. Esta representación es muy ventajosa a la hora de extraer un azulejo al azar para poner en una factoría. La forma de resolverlo es generando un número random entre 1 y la longitud de la lista y el color que ocupe esta posición será retornado y por consiguiente eliminado de la bolsa. 
	
\begin{lstlisting}
create_bag(0, 0, 0, 0, 0, []) :- !.
create_bag(0, 0, 0, 0, W, [5|T]) :- !, W1 is W-1, create_bag(0, 0, 0, 0, W1, T).
create_bag(0, 0, 0, G, W, [4|T]) :- !, G1 is G-1, create_bag(0, 0, 0, G1, W, T).
create_bag(0, 0, R, G, W, [3|T]) :- !, R1 is R-1, create_bag(0, 0, R1, G, W, T).
create_bag(0, Y, R, G, W, [2|T]) :- !, Y1 is Y-1, create_bag(0, Y1, R, G, W, T).
create_bag(B, Y, R, G, W, [1|T]) :- B1 is B-1, create_bag(B1, Y, R, G, W, T). 	

init_bag() :-
	create_bag(20, 20, 20, 20, 20, L),
	assert(bag(100, L)). 

remove_tile_bag(-1) :- bag(N, _), N=:=0, !. %si la bolsa está vacía retorna -1
remove_tile_bag(C) :- bag(N, L), N2 is N-1, N1 is N+1, random(1, N1, I),
                      retract(bag(N, L)), remove(L, I, R, C), assert(bag(N2, R)).

fill_bag() :- bag(N1, B), retract(bag(N1, B)), 
               lid(N2, L), retract(lid(N2, L)),
               concat(B, L, R), N3 is N1 + N2, %concatena la bolsa y la tapa
               assert(bag(N3,R)), assert(lid(0, [])). %la tapa está vacía ahora

\end{lstlisting}

	En la figura 1 se muestra cómo lucen las componentes del ambiente en la salida de la consola. El número $|1|$ en blanco que aparece en Center indica la presencia de la ficha de jugador inicial, mientras que en la figura 3 esta fichita se encuentra en la línea de penalización del jugador 2. En este caso la partida es de dos jugadores por lo que hay 5 factorías, cada una de ellas con sus cuatro azulejos iniciales y la bolsa con los 80 restantes.
	
	\begin{figure}[!ht]
		\centering
		\includegraphics[scale=0.5]{./image/env.png}
		\caption{\small{Componentes del ambiente del juego}}
	\end{figure} 

	
	
	\item {\bf board.pl} En este se encuentran los predicados que definen las partes del tablero de cada jugador. El muro está constituido por 25 celdas dinámicas que en conjunto forman una matriz de $5x5$. Cada celda tiene asignado el $Id$ del jugador correspondiente, la fila, columna, el color de la misma y si está ocupada por un azulejo o no. El predicado \lstinline|cell/5| es dinámico y para actualizar o consultar una posición en el muro se utiliza el siguiente predicado:
\begin{lstlisting}

set_value_wall(ID, I, J, C, V) :- retract(cell(ID, I, J, C, _)),
                                      assert(cell(ID, I, J, C, V)).
:- cell(2, 3, 4, C, V). % C y V unifican con el color y el estado de la 
                        % celda (3, 4) del muro del jugador 2
% Si la celda tiene el azulejo correspondiente => V = 1, si no V = 0
	
\end{lstlisting}

	La representación de la zona de preparación y de la línea de penalización son similares al muro, pues para ellos también se tienen predicados dinámicos \lstinline|stair/4| y \lstinline|floor/5|
	
\begin{lstlisting}
% ID: jugador,  (I, J) posición,  C:color del azulejo
set_value_stair(ID, I, J, C) :-   % si la posición está vacía => C = 0  
	retract(stair(ID, I, J, _)),
	assert(stair(ID, I, J, C)).

% ID: jugador,   Pos: lugar que ocupa en la línea, C: color del azulejo
%                    C = 0 => vacía  
% C = -1 => ficha jugador inicial
set_value_floor(ID, Pos, C) :-                
	retract(floor(ID, Pos, _, Penalty)),    
	assert(floor(ID, Pos, C, Penalty)).
	
%Inicializa el tablero del jugador Id
init_board(ID) :-
	init_matrix_wall(ID),
	init_floor(ID),
	init_stair(ID).

\end{lstlisting}

 A continuación se muestran capturas de la consola
 
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.5]{./image/init2.png}
	\caption{\small{Estado inicial de una partida con 2 jugadores}}
\end{figure} 


\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.5]{./image/end2.png}
	\caption{\small{Estado final de la partida con 2 jugadores }}
\end{figure} 


	
	\newpage
	
	\item {\bf player.pl}: Contiene los predicados relacionados con la inicialización de un jugador y la interacción de este con el ambiente en las diferentes fases del juego.
	
	\begin{lstlisting}
	init_player(ID) :-
	set_score(ID, 0),
	init_board(ID).
	\end{lstlisting}
	
	
	En la Fase I el jugador debe tomar todos los azulejos de un mismo color de una de las ubicaciones posibles y colocarlos en alguna de las filas de su zona de preparación o en el suelo. Para la realización de estas acciones se definió el predicado \lstinline|pick/1|.
	
	\begin{lstlisting}
	pick(ID) :-
		get_moves(ID,All_moves),
		strategy(ID,All_moves,Source, Color, Amount, Stair, Chip),
		update_environment(Source, Color, Chip),
		place_chip(ID, Chip),
		place_colors(ID, Stair, Color, Amount).
	\end{lstlisting}
	
		\begin{itemize}
		\item \lstinline| get_moves(ID,All_moves)|: triunfa si \lstinline|All_moves| es la lista que contiene todas los movimientos factibles a realizar por el jugador \lstinline|ID|.
		
		\item \lstinline| strategy(ID,All_moves,Source, Color, Amount, Stair, Chip)|: triunfa si de todos los movimientos factibles para el jugador \lstinline|ID| contenidos en \lstinline|All_moves| se escoge mover de la ubicación \lstinline|Source| una cantidad \lstinline|Amount| de azulejos de color \lstinline|Color| hacia \lstinline|Stair| con la presencia (\lstinline|Chip| = 1) o no (\lstinline|Chip| = 0) de la ficha de jugador inicial.
		
		\item \lstinline| update_environment(Source, Color, Chip)|:triunfa si
		\begin{itemize}
			\item \lstinline|Source|$ = 0$: se eliminan del centro de la mesa los azulejos de color \lstinline|Color| y si \lstinline|Chip| = 1 se elimina tambi\'en la ficha de jugador inicial.
			\item \lstinline|Source|$\neq 0$: se eliminan de la factor\'ia \lstinline|Source| los azulejos de color \lstinline|Color|.
		\end{itemize} 
		
		\item \lstinline| place_chip(ID, Chip)| triunfa si
				\begin{itemize}
			\item \lstinline|Chip = 0|.
			\item \lstinline|Chip = 1|: si hay espacio en el suelo del jugador \lstinline|ID| se coloca all\'i la ficha de jugador inicial. El predicado \lstinline|first_player/1| es actualizado para la siguiente ronda. 
		\end{itemize} 
		\item  \lstinline| place_colors(ID, Stair, Color, Amount)| : triunfa si
		\begin{itemize}
			\item \lstinline|Stair|$ = 0$: se coloca en el espacio que est\'e disponible del suelo  mediante el predicado \lstinline|update_floor/4| lo que se pueda de los \lstinline|Amount| azulejos de color \lstinline|Color| y si hay algunos que no caben se colocan en la tapa de la caja mediante el predicado \lstinline|update_lid/4|.  
			\item \lstinline|Stair|$\neq 0$: se colocan en la fila \lstinline|Stair| la cantidad de \lstinline|Amount| que sea posible de azulejos de color \lstinline|Color| mediante el predicado \lstinline|update_stair/5|, aquellos que no quepan se colocan en el suelo mientras se pueda mediante el predicado \lstinline|update_floor/4| y si hay alg\'un azulejo que no fue posible colocar en el suelo es enviado a la tapa de la caja mediante el predicado \lstinline|update_lid/4|.   		
		\end{itemize} 
	\end{itemize}
	En la Fase II el jugador transporta un azulejo de cada una de las filas completadas al muro y por cada uno anota puntos, as\'i como pierde puntos por cada azulejo presente en el suelo. Para simular estas acciones se defini\'o el predicado \lstinline|build_wall/1|.
		\begin{lstlisting}
	build_wall(ID) :-
		((setof((Stair, Color),
		(stair(ID, Stair, Stair, Color), Color=\=0),Stairs),
		build_and_clean(ID, Stairs)),!;true),
		floor_penalty(ID),
		clean_floor(ID).
	
	build_and_clean(_, []) :- !.
	build_and_clean(ID, [(Stair, Color)|Stairs]) :-
		set_value_wall(ID, Stair, _, Color, 1),
		calculate_points_horizontal(ID,Stair,Color,Horizontals),
		calculate_points_vertical(ID,Stair,Color,Verticals),
		update_score(ID,Horizontals,Verticals),
		clean_stair(ID, Stair, Color),
		build_and_clean(ID, Stairs).
	\end{lstlisting}
	\begin{itemize}
		\item \lstinline|calculate_points_horizontal(ID,Stair,Color,Horizontals)|: triunfa si \lstinline|Horizontals| es la cantidad de azulejos directamente conectados horizontalmente a la posici\'on del color \lstinline|Color| en la fila \lstinline|Stair| del muro del jugador \lstinline|ID|.
		\item \lstinline|calculate_points_vertical(ID,Stair,Color,Verticals)|: triunfa si \lstinline|Verticals| es la cantidad de azulejos directamente conectados verticalmente a la posici\'on del color \lstinline|Color| de la fila \lstinline|Stair| del muro del jugador \lstinline|ID|.
		\item \lstinline|update_score(ID,Horizontals,Verticals)|:triunfa si se actualiza el predicado \lstinline|player_score/2| para el jugador \lstinline|ID| seg\'un las cantidades de \lstinline|Horizontals| y \lstinline|Verticals|.
		\item \lstinline|clean_stair(ID, Stair, Color)|: triunfa si los azulejos de las filas completas de la zona de preparaci\'on que no son colocados en el muro son colocados en la tapa de la caja mediante el predicado \lstinline|update_lid/4|.
		\item \lstinline|floor_penalty(ID)|: triunfa si la puntuaci\'on del jugador \lstinline|ID| es actualizada seg\'un los azulejos contenidos en su suelo. 
		\item \lstinline|clean_floor(ID)|: triunfa si todos los azulejos colocados en el suelo del jugador \lstinline|ID| son agregados a la tapa de la caja.
	\end{itemize}
	\item {\bf punctuation.pl} Contiene todos los predicados relacionados con mantener la puntuaci\'on de un jugador.\\\\
	 Se define el pedicado din\'amico \lstinline|player_score(ID,Score)| que triunfa si \lstinline|Score| es la puntuaci\'on del jugador \lstinline|ID|.
	 \begin{lstlisting}
	 set_score(ID, SCORE) :-
	 SCORE=<0, !,
	 (   retract(player_score(ID, _)), !
	 ;   true
	 ),
	 assert(player_score(ID, 0)), !.
	 set_score(ID, SCORE) :-
	 SCORE>0,
	 (   retract(player_score(ID, _)), !
	 ;   true
	 ),
	 assert(player_score(ID, SCORE)). 
	\end{lstlisting}
	
	Aqu\'i tambi\'en encontramos los predicados auxiliares necesarios para determinar en cu\'anto var\'ia la puntuaci\'on de un jugador, seg\'un las reglas del juego, tanto en la Fase II como al final de la partida, as\'i como los predicados para reflejar dichas variaciones en \lstinline|player_score/2|.
	   
	\item {\bf strategy.pl}	Contiene los predicados que definen la estrategia de selecci\'on que va a seguir el jugador. En la secci\'on 2 se describe detalladamente cu\'al va a ser dicha estrategia. 
	
	\item {\bf utils.pl} Contiene predicados auxiliares para el trabajo con listas y también imprimir en consola la salida de la simulación.
	
	\item {\bf simulation.pl} Es el archivo principal que se ejecuta, pues contiene los predicados referentes a la ejecución de las tres fases. En la sección 3 se explica con más detenimiento.

\end{itemize}






\section {Estrategia}

Cada jugador tiene que decidir qué azulejos va a tomar, de dónde los va a tomar y dónde los va a colocar, para esto se implementó una estrategia de selección que se va describir a continuación.\\
Como punto de partida es necesario tener un conjunto de todos los movimientos factibles a realizar, donde por movimiento factible se entiende que sea válido colocar en la fila seleccionada (o el suelo) los azulejos de un determinado color tomados de una de las fábricas o el centro de la mesa. Para obtener esto se crearon todas las combinaciones de movimientos posibles, o sea, tanto válidos como inválidos y se filtraron mediante la evaluación del predicado \lstinline|factible_move| para determinar si eran factibles o no.

Sea \lstinline|All_moves| el conjunto de movimientos factibles para el jugador \lstinline|ID|, va a estar representado por una lista de tuplas con el formato \lstinline|[(Source, Color, Amount, Stair, Chip),...]| que indica que se toman \lstinline|Amount| fichas de color \lstinline|Color|(1,2,3,4,5 según el color) desde \lstinline|Source| (0,1...$k$) si son del suelo o de la fábrica $k$ respectivamente) hacia la fila \lstinline|Stair| y \lstinline|Chip| va a ser 0 o 1 en dependencia de si se tomó o no la ficha de jugador inicial. Si \lstinline|All_moves| $\neq \emptyset$  se va a seleccionar un movimiento en el siguiente orden:
\begin{itemize}
	\item[1.] 
	 \begin{itemize}
	 	\item Seleccionar de \lstinline|All_moves| aquellos movimientos que al realizarse completen exactamente una fila y con estos formar el conjunto \lstinline|Moves|.
	 	\item Si el jugador no lleva la delantera en la puntuación tampoco van a pertenecer a \lstinline|Moves| aquellos movimientos que completarían una fila en el muro en la fase 2 y, por tanto, finalizarían la partida.
	 	\item Si \lstinline|Moves| $\neq \emptyset$:
	 	\begin{itemize}
	 		\item Ordenar \lstinline|Moves| de menor a mayor según la cantidad de azulejos directamente conectados en línea recta en la fila y/o columna que tiene en el muro el color que se completaría. 
	 		\item Seleccionar como movimiento a realizar el último elemento de \lstinline|Moves| y parar de buscar, con lo que se busca maximizar el número de puntos a obtener en la fase de revestir el muro. 
	 	\end{itemize} 
	 \end{itemize}
 	\begin{lstlisting}
 	get_moves_overfill(ID, All_moves, K, Moves) :-
 		setof((Ady, Src, Clr, Amnt, St, Ch),
 		Free^(member((Src, Clr, Amnt, St, Ch), All_moves),
 	 	get_free_space(ID, St, Free), Amnt-Free=:=K,
 	  	get_adyacents(ID, St, Clr, Ady),
 	   	(is_not_game_move(ID, St, Clr);is_winning(ID))),
 		Moves).
 		
	strategy(ID, All_moves, Source, Color, Amount, Stair, Chip) :-
		get_moves_overfill(ID, All_moves, 0, Moves),
		last(Moves,
		(_, Source, Color, Amount, Stair, Chip)), !.
 	\end{lstlisting}
 	\item[2.] 
 	\begin{itemize}
 		\item Seleccionar de \lstinline|All_Moves| aquellos movimientos que al realizarse completen una fila y sobre exactamente un azulejo y con estos formar el conjunto \lstinline|Moves|.
 		\item Si el jugador no lleva la delantera en la puntuación tampoco van a pertenecer a \lstinline|Moves| aquellos movimientos que completarían una fila en el muro en la fase 2 y, por tanto, finalizarían la partida. 
 	   \item Si \lstinline|Moves| $\neq \emptyset$:
 	\begin{itemize}
 		\item Ordenar \lstinline|Moves| de menor a mayor según la cantidad de azulejos directamente conectados en línea recta en la fila y/o columna que tiene en el muro el color que se completaría.
 		\item Seleccionar como movimiento a realizar el último elemento de \lstinline|Moves| y parar de buscar. 
 	 	\end{itemize}	
 	\end{itemize}
 \begin{lstlisting}
 	strategy(ID, All_moves, Source, Color, Amount, Stair, Chip) :-
 		get_moves_overfill(ID, All_moves, 1, Moves),
 		last(Moves,
 		(_, Source, Color, Amount, Stair, Chip)), !.
 \end{lstlisting}
 	\item[3.] 
 \begin{itemize}
 	\item Seleccionar de \lstinline|All_Moves| aquellos movimientos que al realizarse no alcancen a completar exactamente una fila y además esta ya contenga al menos un azulejo, y con estos formar el conjunto \lstinline|Moves|.
 	\item Si \lstinline|Moves| $\neq \emptyset$:
 	\begin{itemize}
 		\item Ordenar \lstinline|Moves| de menor a mayor según la cantidad de espacios vacíos que quedarían en la fila al colocar los azulejos.
 		\item Seleccionar como movimiento a realizar el primer elemento de \lstinline|Moves| y parar de buscar.
 	\end{itemize}
  \end{itemize}
 \begin{lstlisting}
 	get_moves_incomplete_to_nonempty(ID, All_moves, Moves) :-
 		setof((Incomplete, Src, Clr, Amnt, St, Ch),
 		Free^(member((Src, Clr, Amnt, St, Ch), All_moves),
 		get_free_space(ID, St, Free), Incomplete is Free-Amnt,
 		Incomplete>0, stair(ID, St, 1, Clr)),
 		Moves).
 		
 	strategy(ID, All_moves, Source, Color, Amount, Stair, Chip) :-
 		get_moves_incomplete_to_nonempty(ID,All_moves,
 		[ (_, Source, Color, Amount, Stair, Chip)|_]), !.
 \end{lstlisting} 
	\item[4.] 
\begin{itemize}
	\item Seleccionar de \lstinline|All_Moves| aquellos movimientos que al realizarse no alcancen a completar exactamente una fila y con estos formar el conjunto \lstinline|Moves|.
	\item Si \lstinline|Moves| $\neq \emptyset$:
	\begin{itemize}
		\item Ordenar \lstinline|Moves| de menor a mayor según la cantidad de espacios vacíos que quedarían en la fila al colocar los azulejos.
		\item Seleccionar como movimiento a realizar el primer elemento de \lstinline|Moves| y parar de buscar.
	\end{itemize} 
\end{itemize}
\begin{lstlisting}
	get_moves_incomplete(ID, All_moves, Moves) :-
		setof((Incomplete, Src, Clr, Amnt, St, Ch),
		Free^(member((Src, Clr, Amnt, St, Ch), All_moves),
	 	get_free_space(ID, St, Free), Incomplete is Free-Amnt,
	  	Incomplete>0),Moves).
	  	
	strategy(ID, All_moves, Source, Color, Amount, Stair, Chip) :-
	  	get_moves_incomplete(ID,All_moves,	  	
	  	[ (_, Source, Color, Amount, Stair, Chip)|_]), !.
\end{lstlisting}
\item[5.] 
\begin{itemize}
	\item Seleccionar de \lstinline|All_Moves| aquellos movimientos que no provocan que se acabe el juego al llenar una fila del muro en la siguiente fase (LLegado a este punto estos movimientos se rechazaron anteriormente porque el jugador no contaba con la mayor puntuación, por tanto ahora tampoco sería conveniente seleccionarlos, mientras que el resto de los movimientos tras haber sido descartados por las variantes anteriores solo pueden ser movimientos que completen una fila y sobre una cantidad mayor que 1 de azulejos que irían al suelo o que no se puedan colocar en  ninguna fila y vayan directamente al suelo) y con estos formar el conjunto \lstinline|Moves|.
	\item Si \lstinline|Moves| $\neq \emptyset$:
	\begin{itemize}
		\item Ordenar \lstinline|Moves| de menor a mayor según la cantidad de azulejos que serían enviados al suelo.
		\item Seleccionar como movimiento a realizar el primer elemento de $F_5$ y parar de buscar.
	\end{itemize} 
\end{itemize}
\begin{lstlisting}
	strategy(ID, All_moves, Source, Color, Amount, Stair, Chip) :-
		setof((Extra, Src, Clr, Amnt, St, Ch),
		Free^(member((Src, Clr, Amnt, St, Ch), All_moves),
		get_free_space(ID, St, Free), Extra is Amnt-Free,
		is_not_game_move(ID, St, Clr)),	
		[ (_, Source, Color, Amount, Stair, Chip)|_]), !.
\end{lstlisting}
\item[6.] 
\begin{itemize}
	\item Alcanzar este punto significa que todos los movimientos en \lstinline|All_Moves| son aquellos que provocan el fin del juego al revestir el muro o que colocan las fichas directamente en el suelo

	\item Ordenar \lstinline|All_Moves| de menor a mayor según la cantidad de azulejos que serían enviados al suelo.
	\item Seleccionar como movimiento a realizar el primer elemento de \lstinline|All_Moves|.
\end{itemize}
\begin{lstlisting}
	strategy(ID, All_moves, Source, Color, Amount, Stair, Chip) :-
		setof((Extra, Src, Clr, Amnt, St, Ch),
		Free^(member((Src, Clr, Amnt, St, Ch), All_moves),
	 	get_free_space(ID, St, Free), Extra is Amnt-Free),
		[ (_, Source, Color, Amount, Stair, Chip)|_]).
\end{lstlisting}
\end{itemize}

\section {Simulación}
Una partida de $Azul$ consta de un número indeterminado de rondas hasta que se cumpla alguna de las  condiciones de finalización, estas pueden ser que al menos un jugador complete una línea en su muro o que se acaben los azulejos y ya no sea posible preparar una nueva ronda. Cada ronda consta a su vez de tres fases:

\begin{itemize}
	\item [1.] Selección de azulejos(Oferta de Factoría)
	\item [2.] Revestimiento del muro(Alicatado de la pared)
	\item [3.] Mantenimiento(Preparación de la siguiente ronda)
\end{itemize}

A modo de resumen del flujo de una partida en el juego, se observan en la figura 4 las transiciones entre las fases y las acciones correspondientes a cada una de ellas.


\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.5]{./image/model3.png}
	\caption{\small{ }}
\end{figure} 

\newpage

A continuación se ofrece la implementación del módulo \lstinline| simulation.pl| en el cual se encuentran definidos los predicados \lstinline| fase_i(X)| para $i = {1,2,3}$ y el predicado \lstinline|simulate(X)|. Una vez inicializado el juego con todas sus componentes y jugadores la simulación comienza al ejecutar \lstinline| simulate(1)| indicando que la próxima fase a ejecutar será la fase 1. Notar que las primeras tres cláusulas del predicado \lstinline| simulate| en esencia cumplen con \lstinline|simulate(I) :- faseI(X), simulate(X)|, pues X unifica con el número de la próxima fase que debe ocurrir en la partida.


\begin{lstlisting}
	
	
fase1(2) :- finish_fase1(), !.
fase1(1) :- next_turn(Next), print_table(), pick(Next), print_board(Next),
             update_next_turn(), !.
fase1(5).

fase2(3) :- !, cant_players(Cant), update_all_walls(Cant). 
fase2(6).

fase3(4) :- check_end_play(), !, print_end(). 
fase3(1) :- prepare_next_round(), !.      
fase3(4) :- print_end_bag(). 

simulate(1) :- fase1(X), simulate(X).
simulate(2) :- printText('END FASE 1\n', red), fase2(X), simulate(X).
simulate(3) :- fase3(X), simulate(X).
simulate(4) :- cant_players(C), winners(C, W, S),  print_play_state(), printText('\n WINNERS !!!!!!', green),  print_winners(W, S).
simulate(5) :- printText('(Error in FASE 1)', red).
simulate(6) :- printText('(Error in FASE 2)', red).

	
\end{lstlisting}

Una vez llegado a la cláusula \lstinline| simulate(4)| es porque se cumplió una de las condiciones de parada, ya sea que triunfó la primera cláusula del predicado \lstinline| fase3(4)|(algún jugador completó una línea) o porque falló \lstinline| fase3(1)| al no poder preparase la siguiente ronda. Estando en este punto se procede a actualizar las puntuaciones de todos los jugadores para definir aquellos que resulten vencedores de la partida.



\section{Ejecución}

Para correr el programa es necesario estar situado sobre la carpeta /src y en consola ejecutar los siguientes comandos:



\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.5]{./image/exe.png}
	\caption{\small{ }}
\end{figure} 

El predicado \lstinline| start_play(C)|  recibe la cantidad de jugadores de la partida.


\end{document}
